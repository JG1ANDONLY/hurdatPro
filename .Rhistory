df <- df[which(df$time == time), ]
df <- df[which(df$date == date),]
pos <- c(df$numeric.longitude, df$numeric.latitude)
return(df)}
map_storm_q5("AL012021", '20210520', '0000')
map_storm_q5 <- function(stormid, date, time){
#get the line of the dataframe which contains the nominated info
datnew = hurdat
df <- datnew[which(datnew$id == stormid), ]
df <- df[which(df$time == time), ]
df <- df[which(df$date == date),]
pos <- c(df$numeric.longitude, df$numeric.latitude)
return(df)}
map_storm_q5 <- function(stormid, date, time){
#get the line of the dataframe which contains the nominated info
datnew = hurdat
df <- datnew[which(datnew$id == stormid), ]
df <- df[which(df$time == time), ]
df <- df[which(df$date == date),]
pos <- c(df$numeric.longitude, df$numeric.latitude)
return(df)}
map_storm_q5("AL012021", '20210520', '0000')
View(hurdat)
map_storm_q5("AL062021", '20210820', '0000')
map_storm_q5 <- function(stormid, date, time){
#get the line of the dataframe which contains the nominated info
datnew = hurdat
df <- datnew[which(datnew$id %in% stormid), ]
df <- df[which(df$time %in% time), ]
df <- df[which(df$date %in% date), ]
pos <- c(df$numeric.longitude, df$numeric.latitude)
return(df)
}
map_storm_q5("AL062021", '20210820', '0000')
getwd()
load("hurdat.RData")
library(tidyverse)
View(hurdat)
hurdat_grouped <- hurdat %>% group_by(id)
View(hurdat_grouped)
hurdat_grouped <- hurdat %>% group_by(id) %>% group_split()
View(hurdat_grouped)
break
for (list in hurdat_grouped) {
print(list)
break
}
View(hurdat)
# Get the boundary polygon of the continental US
us_poly <- map("usa", plot = FALSE, fill = TRUE)
View(us_poly)
View(hurdat)
track <- hurdat[which(hurdat$id %in% "AL011851"), c("numeric.latitude",
"numeric.longitude")]
View(track)
storm_landfall <- function(storm.ids) {
# Get the boundary polygon of the continental US
us_poly <- map("usa", plot = FALSE, fill = TRUE)
track <- hurdat[which(hurdat$id %in% storm.ids), c("numeric.latitude",
"numeric.longitude")]
# lon <- track$numeric.longitude
# lat <- track$numeric.latitude
storm_point <- SpatialPoints(track)
# Check whether the storm's location is within the US boundary polygon
is_in_us <- point.in.polygon(storm_point, us_poly$x, us_poly$y)
# Return a logical value indicating whether the storm made landfall in the US
return(is_in_us)
}
storm_landfall("AL011851")
View(track)
SpatialPoints(track)
storm_landfall <- function(storm.ids) {
# Get the boundary polygon of the continental US
us_poly <- map("usa", plot = FALSE, fill = TRUE)
track <- hurdat[which(hurdat$id %in% storm.ids), c("numeric.latitude",
"numeric.longitude")]
# lon <- track$numeric.longitude
# lat <- track$numeric.latitude
storm_point <- SpatialPoints(track)
print("here")
# Check whether the storm's location is within the US boundary polygon
is_in_us <- point.in.polygon(storm_point, us_poly$x, us_poly$y)
# Return a logical value indicating whether the storm made landfall in the US
return(is_in_us)
}
storm_landfall("AL011851")
storm_landfall <- function(storm.ids) {
library(sp)
library(maps)
# Get the boundary polygon of the continental US
us_poly <- map("usa", plot = FALSE, fill = TRUE)
track <- hurdat[which(hurdat$id %in% storm.ids), c("numeric.latitude",
"numeric.longitude")]
# lon <- track$numeric.longitude
# lat <- track$numeric.latitude
storm_point <- SpatialPoints(track)
print("here")
# Check whether the storm's location is within the US boundary polygon
is_in_us <- point.in.polygon(storm_point, us_poly$x, us_poly$y)
# Return a logical value indicating whether the storm made landfall in the US
return(is_in_us)
}
storm_landfall("AL011851")
?point.in.polygon
storm_point <- SpatialPoints(track)
View(storm_point)
View(us_poly)
View(storm_point)
storm_point$coords
print(storm_point)
storm_point$numeric.latitude
storm_landfall <- function(storm.ids) {
library(sp)
library(maps)
# Get the boundary polygon of the continental US
us_poly <- map("usa", plot = FALSE, fill = TRUE)
track <- hurdat[which(hurdat$id %in% storm.ids), c("numeric.latitude",
"numeric.longitude")]
# lon <- track$numeric.longitude
# lat <- track$numeric.latitude
storm_point <- SpatialPoints(track)
print("here")
print(typeof(storm_point))
# Check whether the storm's location is within the US boundary polygon
is_in_us <- point.in.polygon(storm_point$numeric.longitude,
storm_point$numeric.latitude,
us_poly$x, us_poly$y)
# Return a logical value indicating whether the storm made landfall in the US
return(is_in_us)
}
storm_landfall("AL011851")
storm_landfall <- function(storm.ids) {
library(sp)
library(maps)
# Get the boundary polygon of the continental US
us_poly <- map("usa", plot = FALSE, fill = TRUE)
track <- hurdat[which(hurdat$id %in% storm.ids), c("numeric.latitude",
"numeric.longitude")]
# lon <- track$numeric.longitude
# lat <- track$numeric.latitude
storm_point <- SpatialPoints(track)
# Check whether the storm's location is within the US boundary polygon
is_in_us <- point.in.polygon(storm_point$numeric.longitude,
storm_point$numeric.latitude,
us_poly$x, us_poly$y)
# Return a logical value indicating whether the storm made landfall in the US
return(is_in_us)
}
storm_landfall("AL011851")
?is_in_us
?point.in.polygon
?if_any()
storm_landfall <- function(storm.ids) {
library(sp)
library(maps)
# Get the boundary polygon of the continental US
us_poly <- map("usa", plot = FALSE, fill = TRUE)
track <- hurdat[which(hurdat$id %in% storm.ids), c("numeric.latitude",
"numeric.longitude")]
# lon <- track$numeric.longitude
# lat <- track$numeric.latitude
storm_point <- SpatialPoints(track)
# Check whether the storm's location is within the US boundary polygon
is_in_us <- point.in.polygon(storm_point$numeric.longitude,
storm_point$numeric.latitude,
us_poly$x, us_poly$y)
# Return a logical value indicating whether the storm made landfall in the US
return(any(is_in_us != 0))
}
storm_landfall("AL011851")
storm_landfall("AL041852")
storm_landfall(c("AL011851", "AL041852"))
storm_landfall <- function(storm.ids) {
library(sp)
library(maps)
# Get the boundary polygon of the continental US
us_poly <- map("usa", plot = FALSE, fill = TRUE)
is_in_us <- c()
for (id in storm.ids){
track <- hurdat[which(hurdat$id %in% storm.ids), c("numeric.latitude",
"numeric.longitude")]
storm_point <- SpatialPoints(track)
is_in_us <- append(is_in_us, any(point.in.polygon(storm_point$numeric.longitude,
storm_point$numeric.latitude,
us_poly$x, us_poly$y) != 0))
}
return(any(is_in_us != 0))
}
storm_landfall("AL011851")
storm_landfall(c("AL011851", "AL041852"))
storm_landfall <- function(storm.ids) {
library(sp)
library(maps)
# Get the boundary polygon of the continental US
us_poly <- map("usa", plot = FALSE, fill = TRUE)
is_in_us <- c()
for (id in storm.ids){
track <- hurdat[which(hurdat$id %in% storm.ids), c("numeric.latitude",
"numeric.longitude")]
storm_point <- SpatialPoints(track)
is_in_us <- append(is_in_us, any(point.in.polygon(storm_point$numeric.longitude,
storm_point$numeric.latitude,
us_poly$x, us_poly$y) != 0))
}
return(is_in_us)
}
storm_landfall("AL011851")
storm_landfall(c("AL011851", "AL041852"))
styler:::style_active_file()
getwd(())
getwd()
load("hurdat.RData")
View(hurdat)
colnames(hurdat)
getwd)_
getwd()
setwd("/Users/guozhongyi/Desktop/hurdatPro/R")
devtools::document("data.r")
# load data
devtools::document("hurdat.RData")
# load data
devtools::document("../data/hurdat.RData")
getwd()
?document
# load data
devtools::document()
# load data
devtools::document()
# load data
devtools::document()
load("hurdat")
load("hurdat.RData")
load(hurdat)
load("hurdat.Rd")
tormz_30min_incre <- function(storm.id) {
# determine if the input is empty
if (length(storm.id) == 0) {
stop("The input storm ID cannot be empty")
}
# determine if the input is a valid storm ID
if (!all(storm.id %in% hurdat$id)) {
stop("At least 1 value of the input is a valid storm ID.")
}
# load data
devtools::document()
load("hurdat.Rd")
# subset hurdat based on input ID
track <- hurdat[
which(hurdat$id %in% storm.id),
c("id", "date", "time", "numeric.latitude", "numeric.longitude")
]
# create a new empty dataframe for later appending
newDF <- data.frame(id = c(), date = c(), time = c(), numeric.latitude = c(),
numeric.longitude = c())
# split dataframe based on ID
track_list <- split(track, track$id)
# loop through splitted dataframe
for (eachTrack in track_list) {
eachTrack$time <- trimws(eachTrack$time)
date_list <- split(eachTrack, eachTrack$date)
for (eachDate in date_list) {
eachDate <- rbind(eachDate, c(
eachDate$id[nrow(eachDate)],
eachDate$date[nrow(eachDate)], "2400",
eachDate$numeric.latitude[nrow(eachDate)],
eachDate$numeric.longitude[nrow(eachDate)]
))
rownames(eachDate) <- seq(nrow(eachDate))
for (index in 1:(nrow(eachDate) - 1)) {
start <- eachDate[index, "time"]
startHour <- substr(start, start = 1, stop = 2)
startMin <- substr(start, start = 3, stop = 4)
startTime <- paste0(startHour, ":", startMin)
end <- eachDate[index + 1, "time"]
endHour <- substr(end, start = 1, stop = 2)
endMin <- substr(end, start = 3, stop = 4)
endTime <- paste0(endHour, ":", endMin)
startTime <- strptime(startTime, format = "%H:%M")
endTime <- strptime(endTime, format = "%H:%M")
startEnd30Interval <- format(
seq.POSIXt(
from = startTime,
to = endTime, by = "30 min"
),
format = "%H%M"
)
startEnd30Interval <- head(startEnd30Interval, -1)
temp <- data.frame(
id = eachDate$id[index],
date = eachDate$date[index],
time = startEnd30Interval,
numeric.latitude = eachDate$numeric.latitude[index],
numeric.longitude = eachDate$numeric.longitude[index]
)
newDF <- rbind(newDF, temp)
}
}
return(newDF)
}
}
stormz_30min_incre <- function(storm.id) {
# determine if the input is empty
if (length(storm.id) == 0) {
stop("The input storm ID cannot be empty")
}
# determine if the input is a valid storm ID
if (!all(storm.id %in% hurdat$id)) {
stop("At least 1 value of the input is a valid storm ID.")
}
# load data
devtools::document()
load("hurdat.Rd")
# subset hurdat based on input ID
track <- hurdat[
which(hurdat$id %in% storm.id),
c("id", "date", "time", "numeric.latitude", "numeric.longitude")
]
# create a new empty dataframe for later appending
newDF <- data.frame(id = c(), date = c(), time = c(), numeric.latitude = c(),
numeric.longitude = c())
# split dataframe based on ID
track_list <- split(track, track$id)
# loop through splitted dataframe
for (eachTrack in track_list) {
eachTrack$time <- trimws(eachTrack$time)
date_list <- split(eachTrack, eachTrack$date)
for (eachDate in date_list) {
eachDate <- rbind(eachDate, c(
eachDate$id[nrow(eachDate)],
eachDate$date[nrow(eachDate)], "2400",
eachDate$numeric.latitude[nrow(eachDate)],
eachDate$numeric.longitude[nrow(eachDate)]
))
rownames(eachDate) <- seq(nrow(eachDate))
for (index in 1:(nrow(eachDate) - 1)) {
start <- eachDate[index, "time"]
startHour <- substr(start, start = 1, stop = 2)
startMin <- substr(start, start = 3, stop = 4)
startTime <- paste0(startHour, ":", startMin)
end <- eachDate[index + 1, "time"]
endHour <- substr(end, start = 1, stop = 2)
endMin <- substr(end, start = 3, stop = 4)
endTime <- paste0(endHour, ":", endMin)
startTime <- strptime(startTime, format = "%H:%M")
endTime <- strptime(endTime, format = "%H:%M")
startEnd30Interval <- format(
seq.POSIXt(
from = startTime,
to = endTime, by = "30 min"
),
format = "%H%M"
)
startEnd30Interval <- head(startEnd30Interval, -1)
temp <- data.frame(
id = eachDate$id[index],
date = eachDate$date[index],
time = startEnd30Interval,
numeric.latitude = eachDate$numeric.latitude[index],
numeric.longitude = eachDate$numeric.longitude[index]
)
newDF <- rbind(newDF, temp)
}
}
return(newDF)
}
}
stormz_30min_incre("AL011851")
stormz_30min_incre <- function(storm.id) {
# determine if the input is empty
if (length(storm.id) == 0) {
stop("The input storm ID cannot be empty")
}
# determine if the input is a valid storm ID
if (!all(storm.id %in% hurdat$id)) {
stop("At least 1 value of the input is a valid storm ID.")
}
# load data
devtools::document()
load("hurdat.RData")
# subset hurdat based on input ID
track <- hurdat[
which(hurdat$id %in% storm.id),
c("id", "date", "time", "numeric.latitude", "numeric.longitude")
]
# create a new empty dataframe for later appending
newDF <- data.frame(id = c(), date = c(), time = c(), numeric.latitude = c(),
numeric.longitude = c())
# split dataframe based on ID
track_list <- split(track, track$id)
# loop through splitted dataframe
for (eachTrack in track_list) {
eachTrack$time <- trimws(eachTrack$time)
date_list <- split(eachTrack, eachTrack$date)
for (eachDate in date_list) {
eachDate <- rbind(eachDate, c(
eachDate$id[nrow(eachDate)],
eachDate$date[nrow(eachDate)], "2400",
eachDate$numeric.latitude[nrow(eachDate)],
eachDate$numeric.longitude[nrow(eachDate)]
))
rownames(eachDate) <- seq(nrow(eachDate))
for (index in 1:(nrow(eachDate) - 1)) {
start <- eachDate[index, "time"]
startHour <- substr(start, start = 1, stop = 2)
startMin <- substr(start, start = 3, stop = 4)
startTime <- paste0(startHour, ":", startMin)
end <- eachDate[index + 1, "time"]
endHour <- substr(end, start = 1, stop = 2)
endMin <- substr(end, start = 3, stop = 4)
endTime <- paste0(endHour, ":", endMin)
startTime <- strptime(startTime, format = "%H:%M")
endTime <- strptime(endTime, format = "%H:%M")
startEnd30Interval <- format(
seq.POSIXt(
from = startTime,
to = endTime, by = "30 min"
),
format = "%H%M"
)
startEnd30Interval <- head(startEnd30Interval, -1)
temp <- data.frame(
id = eachDate$id[index],
date = eachDate$date[index],
time = startEnd30Interval,
numeric.latitude = eachDate$numeric.latitude[index],
numeric.longitude = eachDate$numeric.longitude[index]
)
newDF <- rbind(newDF, temp)
}
}
return(newDF)
}
}
stormz_30min_incre("AL011851")
getwd()
setwd("/Users/guozhongyi/Desktop/hurdatPro/data")
load("hurdat.RData")
View(hurdat)
stormz_30min_incre <- function(storm.id) {
# determine if the input is empty
if (length(storm.id) == 0) {
stop("The input storm ID cannot be empty")
}
# determine if the input is a valid storm ID
if (!all(storm.id %in% hurdat$id)) {
stop("At least 1 value of the input is a valid storm ID.")
}
# load data
# devtools::document()
# load
# subset hurdat based on input ID
track <- hurdat[
which(hurdat$id %in% storm.id),
c("id", "date", "time", "numeric.latitude", "numeric.longitude")
]
# create a new empty dataframe for later appending
newDF <- data.frame(id = c(), date = c(), time = c(), numeric.latitude = c(),
numeric.longitude = c())
# split dataframe based on ID
track_list <- split(track, track$id)
# loop through splitted dataframe
for (eachTrack in track_list) {
eachTrack$time <- trimws(eachTrack$time)
date_list <- split(eachTrack, eachTrack$date)
for (eachDate in date_list) {
eachDate <- rbind(eachDate, c(
eachDate$id[nrow(eachDate)],
eachDate$date[nrow(eachDate)], "2400",
eachDate$numeric.latitude[nrow(eachDate)],
eachDate$numeric.longitude[nrow(eachDate)]
))
rownames(eachDate) <- seq(nrow(eachDate))
for (index in 1:(nrow(eachDate) - 1)) {
start <- eachDate[index, "time"]
startHour <- substr(start, start = 1, stop = 2)
startMin <- substr(start, start = 3, stop = 4)
startTime <- paste0(startHour, ":", startMin)
end <- eachDate[index + 1, "time"]
endHour <- substr(end, start = 1, stop = 2)
endMin <- substr(end, start = 3, stop = 4)
endTime <- paste0(endHour, ":", endMin)
startTime <- strptime(startTime, format = "%H:%M")
endTime <- strptime(endTime, format = "%H:%M")
startEnd30Interval <- format(
seq.POSIXt(
from = startTime,
to = endTime, by = "30 min"
),
format = "%H%M"
)
startEnd30Interval <- head(startEnd30Interval, -1)
temp <- data.frame(
id = eachDate$id[index],
date = eachDate$date[index],
time = startEnd30Interval,
numeric.latitude = eachDate$numeric.latitude[index],
numeric.longitude = eachDate$numeric.longitude[index]
)
newDF <- rbind(newDF, temp)
}
}
return(newDF)
}
}
stormz_30min_incre("AL011851")
devtools::load_all()
getwd()
setwd("/Users/guozhongyi/Desktop/hurdatPro/")
devtools::load_all()
devtools::load_all()
devtools::load_all()
devtools::load_all()
