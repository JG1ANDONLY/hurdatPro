geom_point(data = data.frame(pos[1],pos[2]),
aes(x = pos[1], y = pos[2], color="position"), size = 3)+
ggtitle("Storm position and size")+
xlab("Longitude") +
ylab("Latitude") +
xlim(-128.5, -36.5) +
ylim(23, 50)
return(map)
}
load("hurdat.RData")
View(hurdat)
position_size("AL172022", "20221110", "1800")
position_size("AL172022", "20221110", "1800")
position_size("AL172022", "20221110", "1800")
position_size <- function(stormid, date, time){
#get the line of the dataframe which contains the nominated info
datnew <- hurdat
df <- datnew[which(datnew$id == stormid), ]
df <- df[which(df$time == time), ]
df <- df[which(df$date == date),]
pos <- c(df$numeric.longitude, df$numeric.latitude)
#50knots
k34 <- get_coord_stormmap(df, "34")
x34 <- k34$x
y34 <- k34$y
#50knots
k50 <- get_coord_stormmap(df, "50")
x50 <- k50$x
y50 <- k50$y
#64knots
k64 <- get_coord_stormmap(df, "64")
x64 <- k64$x
y64 <- k64$y
#generate map
library(ggplot2)
library(maps)
map_projection <- "+proj=longlat +datum=WGS84"
world_map <- map_data("world")
us_map <- map_data("state")
map <- ggplot() +
# Add world map
geom_map(data = world_map, map = world_map, aes(map_id = region),
fill = "white", color = "black", linewidth = 0.2) +
# Add US state map
geom_map(data = us_map, map = us_map, aes(map_id = region),
fill = "grey", color = "black", linewidth = 0.2)+
# Add 34 knot, 50 knot, 64 knot
geom_polygon(data = k34, aes(x = x34, y = y34, color="34knot"),
fill = NA, linewidth = 1)+
geom_polygon(data = k50, aes(x = x50, y = y50, color="50knot"),
fill = NA, linewidth = 1)+
geom_polygon(data = k64, aes(x = x64, y = y64, color="64knot"),
fill = NA, linewidth = 1)+
geom_point(data = data.frame(pos[1],pos[2]),
aes(x = pos[1], y = pos[2], color="position"), size = 3)+
ggtitle("Storm position and size")+
xlab("Longitude") +
ylab("Latitude") +
xlim(-128.5, -63.5) +
ylim(23, 50)
return(map)
}
position_size("AL172022", "20221110", "1800")
for (i in "test"){}
for (i in "test"){print(i)}
getwd()
load("hurdat.RData")
View(hurdat)
getwd()
load("hurdat.RData")
View(hurdat)
setwd("/Users/guozhongyi/Desktop/hurdatPro")
devtools::document()
devtools::document()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
library(devtools)
check()
storm_30min_incre <- function(storm.id) {
# determine if the input is empty
if (length(storm.id) == 0) {
stop("The input storm ID cannot be empty")
}
# determine if the input is a valid storm ID
if (!all(storm.id %in% hurdat$id)) {
stop("At least 1 value of the input is a valid storm ID.")
}
# load data
# devtools::document()
# load
# subset hurdat based on input ID
track <- hurdat[
which(hurdat$id %in% storm.id),
c("id", "date", "time", "numeric.latitude", "numeric.longitude")
]
# create a new empty dataframe for later appending
newDF <- data.frame(id = c(), date = c(), time = c(), numeric.latitude = c(),
numeric.longitude = c())
# split dataframe based on ID
track_list <- split(track, track$id)
# loop through splitted dataframe
for (eachTrack in track_list) {
date_list <- split(eachTrack, eachTrack$date)
for (eachDate in date_list) {
eachDate <- rbind(eachDate, c(
eachDate$id[nrow(eachDate)],
eachDate$date[nrow(eachDate)], "2400",
eachDate$numeric.latitude[nrow(eachDate)],
eachDate$numeric.longitude[nrow(eachDate)]
))
rownames(eachDate) <- seq(nrow(eachDate))
for (index in 1:(nrow(eachDate) - 1)) {
start <- eachDate[index, "time"]
startHour <- substr(start, start = 1, stop = 2)
startMin <- substr(start, start = 3, stop = 4)
startTime <- paste0(startHour, ":", startMin)
end <- eachDate[index + 1, "time"]
endHour <- substr(end, start = 1, stop = 2)
endMin <- substr(end, start = 3, stop = 4)
endTime <- paste0(endHour, ":", endMin)
startTime <- strptime(startTime, format = "%H:%M")
endTime <- strptime(endTime, format = "%H:%M")
startEnd30Interval <- format(
seq.POSIXt(
from = startTime,
to = endTime, by = "30 min"
),
format = "%H%M"
)
startEnd30Interval <- head(startEnd30Interval, -1)
temp <- data.frame(
id = eachDate$id[index],
date = eachDate$date[index],
time = startEnd30Interval,
numeric.latitude = eachDate$numeric.latitude[index],
numeric.longitude = eachDate$numeric.longitude[index]
)
newDF <- rbind(newDF, temp)
}
}
return(newDF)
}
}
storm_30min_incre <- function(storm.id) {
# determine if the input is empty
if (length(storm.id) == 0) {
stop("The input storm ID cannot be empty")
}
# determine if the input is a valid storm ID
if (!all(storm.id %in% hurdat$id)) {
stop("At least 1 value of the input is a valid storm ID.")
}
# load data
# devtools::document()
data("hurdat")
# subset hurdat based on input ID
track <- hurdat[
which(hurdat$id %in% storm.id),
c("id", "date", "time", "numeric.latitude", "numeric.longitude")
]
# create a new empty dataframe for later appending
newDF <- data.frame(id = c(), date = c(), time = c(), numeric.latitude = c(),
numeric.longitude = c())
# split dataframe based on ID
track_list <- split(track, track$id)
# loop through splitted dataframe
for (eachTrack in track_list) {
date_list <- split(eachTrack, eachTrack$date)
for (eachDate in date_list) {
eachDate <- rbind(eachDate, c(
eachDate$id[nrow(eachDate)],
eachDate$date[nrow(eachDate)], "2400",
eachDate$numeric.latitude[nrow(eachDate)],
eachDate$numeric.longitude[nrow(eachDate)]
))
rownames(eachDate) <- seq(nrow(eachDate))
for (index in 1:(nrow(eachDate) - 1)) {
start <- eachDate[index, "time"]
startHour <- substr(start, start = 1, stop = 2)
startMin <- substr(start, start = 3, stop = 4)
startTime <- paste0(startHour, ":", startMin)
end <- eachDate[index + 1, "time"]
endHour <- substr(end, start = 1, stop = 2)
endMin <- substr(end, start = 3, stop = 4)
endTime <- paste0(endHour, ":", endMin)
startTime <- strptime(startTime, format = "%H:%M")
endTime <- strptime(endTime, format = "%H:%M")
startEnd30Interval <- format(
seq.POSIXt(
from = startTime,
to = endTime, by = "30 min"
),
format = "%H%M"
)
startEnd30Interval <- head(startEnd30Interval, -1)
temp <- data.frame(
id = eachDate$id[index],
date = eachDate$date[index],
time = startEnd30Interval,
numeric.latitude = eachDate$numeric.latitude[index],
numeric.longitude = eachDate$numeric.longitude[index]
)
newDF <- rbind(newDF, temp)
}
}
return(newDF)
}
}
storm_ids <- c("AL011851", "AL021851")
storm_30min_incre(storm_ids)
# load data
# devtools::document()
data("hurdat")
View(hurdat)
storm_30min_incre <- function(storm.id) {
# determine if the input is empty
if (length(storm.id) == 0) {
stop("The input storm ID cannot be empty")
}
# determine if the input is a valid storm ID
if (!all(storm.id %in% hurdat$id)) {
stop("At least 1 value of the input is a valid storm ID.")
}
# load data
# devtools::document()
data("hurdat")
# subset hurdat based on input ID
track <- hurdat[
which(hurdat$id %in% storm.id),
c("id", "date", "time", "numeric.latitude", "numeric.longitude")
]
# create a new empty dataframe for later appending
newDF <- data.frame(id = c(), date = c(), time = c(), numeric.latitude = c(),
numeric.longitude = c())
# split dataframe based on ID
track_list <- split(track, track$id)
# loop through splitted dataframe
for (eachTrack in track_list) {
date_list <- split(eachTrack, eachTrack$date)
for (eachDate in date_list) {
eachDate <- rbind(eachDate, c(
eachDate$id[nrow(eachDate)],
eachDate$date[nrow(eachDate)], "2400",
eachDate$numeric.latitude[nrow(eachDate)],
eachDate$numeric.longitude[nrow(eachDate)]
))
rownames(eachDate) <- seq(nrow(eachDate))
for (index in 1:(nrow(eachDate) - 1)) {
start <- eachDate[index, "time"]
startHour <- substr(start, start = 1, stop = 2)
startMin <- substr(start, start = 3, stop = 4)
startTime <- paste0(startHour, ":", startMin)
end <- eachDate[index + 1, "time"]
endHour <- substr(end, start = 1, stop = 2)
endMin <- substr(end, start = 3, stop = 4)
endTime <- paste0(endHour, ":", endMin)
startTime <- strptime(startTime, format = "%H:%M")
endTime <- strptime(endTime, format = "%H:%M")
startEnd30Interval <- format(
seq.POSIXt(
from = startTime,
to = endTime, by = "30 min"
),
format = "%H%M"
)
startEnd30Interval <- head(startEnd30Interval, -1)
temp <- data.frame(
id = eachDate$id[index],
date = eachDate$date[index],
time = startEnd30Interval,
numeric.latitude = eachDate$numeric.latitude[index],
numeric.longitude = eachDate$numeric.longitude[index]
)
newDF <- rbind(newDF, temp)
}
}
return(newDF)
}
}
getwd()
storm_30min_incre(storm_ids)
storm_30min_incre <- function(storm.id) {
# determine if the input is empty
if (length(storm.id) == 0) {
stop("The input storm ID cannot be empty")
}
# determine if the input is a valid storm ID
if (!all(storm.id %in% hurdat$id)) {
stop("At least 1 value of the input is a valid storm ID.")
}
# load data
# devtools::document()
data("hurdat")
# subset hurdat based on input ID
track <- hurdat[
which(hurdat$id %in% storm.id),
c("id", "date", "time", "numeric.latitude", "numeric.longitude")
]
# create a new empty dataframe for later appending
newDF <- data.frame(id = c(), date = c(), time = c(), numeric.latitude = c(),
numeric.longitude = c())
# split dataframe based on ID
track_list <- split(track, track$id)
# loop through splitted dataframe
for (eachTrack in track_list) {
date_list <- split(eachTrack, eachTrack$date)
for (eachDate in date_list) {
eachDate <- rbind(eachDate, c(
eachDate$id[nrow(eachDate)],
eachDate$date[nrow(eachDate)], "2400",
eachDate$numeric.latitude[nrow(eachDate)],
eachDate$numeric.longitude[nrow(eachDate)]
))
rownames(eachDate) <- seq(nrow(eachDate))
for (index in 1:(nrow(eachDate) - 1)) {
start <- eachDate[index, "time"]
startHour <- substr(start, start = 1, stop = 2)
startMin <- substr(start, start = 3, stop = 4)
startTime <- paste0(startHour, ":", startMin)
end <- eachDate[index + 1, "time"]
endHour <- substr(end, start = 1, stop = 2)
endMin <- substr(end, start = 3, stop = 4)
endTime <- paste0(endHour, ":", endMin)
startTime <- strptime(startTime, format = "%H:%M")
endTime <- strptime(endTime, format = "%H:%M")
startEnd30Interval <- format(
seq.POSIXt(
from = startTime,
to = endTime, by = "30 min"
),
format = "%H%M"
)
startEnd30Interval <- head(startEnd30Interval, -1)
temp <- data.frame(
id = eachDate$id[index],
date = eachDate$date[index],
time = startEnd30Interval,
numeric.latitude = eachDate$numeric.latitude[index],
numeric.longitude = eachDate$numeric.longitude[index]
)
newDF <- rbind(newDF, temp)
}
}
return(newDF)
}
}
storm_ids <- c("AL011851", "AL021851")
storm_30min_incre(storm_ids)
# load data
# devtools::document()
data("hurdat")
storm_30min_incre <- function(storm.id) {
# determine if the input is empty
if (length(storm.id) == 0) {
stop("The input storm ID cannot be empty")
}
# determine if the input is a valid storm ID
if (!all(storm.id %in% hurdat$id)) {
stop("At least 1 value of the input is a valid storm ID.")
}
# load data
# devtools::document()
print("before loading")
data("hurdat")
print("after loading")
# subset hurdat based on input ID
track <- hurdat[
which(hurdat$id %in% storm.id),
c("id", "date", "time", "numeric.latitude", "numeric.longitude")
]
# create a new empty dataframe for later appending
newDF <- data.frame(id = c(), date = c(), time = c(), numeric.latitude = c(),
numeric.longitude = c())
# split dataframe based on ID
track_list <- split(track, track$id)
# loop through splitted dataframe
for (eachTrack in track_list) {
date_list <- split(eachTrack, eachTrack$date)
for (eachDate in date_list) {
eachDate <- rbind(eachDate, c(
eachDate$id[nrow(eachDate)],
eachDate$date[nrow(eachDate)], "2400",
eachDate$numeric.latitude[nrow(eachDate)],
eachDate$numeric.longitude[nrow(eachDate)]
))
rownames(eachDate) <- seq(nrow(eachDate))
for (index in 1:(nrow(eachDate) - 1)) {
start <- eachDate[index, "time"]
startHour <- substr(start, start = 1, stop = 2)
startMin <- substr(start, start = 3, stop = 4)
startTime <- paste0(startHour, ":", startMin)
end <- eachDate[index + 1, "time"]
endHour <- substr(end, start = 1, stop = 2)
endMin <- substr(end, start = 3, stop = 4)
endTime <- paste0(endHour, ":", endMin)
startTime <- strptime(startTime, format = "%H:%M")
endTime <- strptime(endTime, format = "%H:%M")
startEnd30Interval <- format(
seq.POSIXt(
from = startTime,
to = endTime, by = "30 min"
),
format = "%H%M"
)
startEnd30Interval <- head(startEnd30Interval, -1)
temp <- data.frame(
id = eachDate$id[index],
date = eachDate$date[index],
time = startEnd30Interval,
numeric.latitude = eachDate$numeric.latitude[index],
numeric.longitude = eachDate$numeric.longitude[index]
)
newDF <- rbind(newDF, temp)
}
}
return(newDF)
}
}
storm_ids <- "AL011851"
storm_30min_incre(storm_ids)
storm_30min_incre <- function(storm.id) {
data("hurdat")
# determine if the input is empty
if (length(storm.id) == 0) {
stop("The input storm ID cannot be empty")
}
# determine if the input is a valid storm ID
if (!all(storm.id %in% hurdat$id)) {
stop("At least 1 value of the input is a valid storm ID.")
}
# subset hurdat based on input ID
track <- hurdat[
which(hurdat$id %in% storm.id),
c("id", "date", "time", "numeric.latitude", "numeric.longitude")
]
# create a new empty dataframe for later appending
newDF <- data.frame(id = c(), date = c(), time = c(), numeric.latitude = c(),
numeric.longitude = c())
# split dataframe based on ID
track_list <- split(track, track$id)
# loop through splitted dataframe
for (eachTrack in track_list) {
date_list <- split(eachTrack, eachTrack$date)
for (eachDate in date_list) {
eachDate <- rbind(eachDate, c(
eachDate$id[nrow(eachDate)],
eachDate$date[nrow(eachDate)], "2400",
eachDate$numeric.latitude[nrow(eachDate)],
eachDate$numeric.longitude[nrow(eachDate)]
))
rownames(eachDate) <- seq(nrow(eachDate))
for (index in 1:(nrow(eachDate) - 1)) {
start <- eachDate[index, "time"]
startHour <- substr(start, start = 1, stop = 2)
startMin <- substr(start, start = 3, stop = 4)
startTime <- paste0(startHour, ":", startMin)
end <- eachDate[index + 1, "time"]
endHour <- substr(end, start = 1, stop = 2)
endMin <- substr(end, start = 3, stop = 4)
endTime <- paste0(endHour, ":", endMin)
startTime <- strptime(startTime, format = "%H:%M")
endTime <- strptime(endTime, format = "%H:%M")
startEnd30Interval <- format(
seq.POSIXt(
from = startTime,
to = endTime, by = "30 min"
),
format = "%H%M"
)
startEnd30Interval <- head(startEnd30Interval, -1)
temp <- data.frame(
id = eachDate$id[index],
date = eachDate$date[index],
time = startEnd30Interval,
numeric.latitude = eachDate$numeric.latitude[index],
numeric.longitude = eachDate$numeric.longitude[index]
)
newDF <- rbind(newDF, temp)
}
}
return(newDF)
}
}
storm_ids <- c("AL011851", "AL021851")
storm_30min_incre(storm_ids)
getwd()
devtools::document()
data("hurdat")
test <- data("hurdat")
devtools::document()
storm_ids <- c("AL011851", "AL021851")
if (!all(storm.id %in% hurdat$id)) {
stop("At least 1 value of the input is a valid storm ID.")
}
if (!all(storm_ids %in% hurdat$id)) {
stop("At least 1 value of the input is a valid storm ID.")
}
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
